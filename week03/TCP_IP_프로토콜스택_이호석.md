# 📌 2장: TCP/IP의 데이터를 전기 신호로 만들어 보낸다.(4~6절)

## ✅ 서버에서 연결을 끊어 소켓을 말소한다.

### 1. 데이터 보내기를 완료했을 때 연결을 끊는다 (`close()`)

- **언제 데이터 송수신을 종료하고, 누가 종료하는가?**
    - 데이터 송수신을 종료하는 것은 애플리케이션이 송신해야 하는 데이터를 전부 송신 완료했다고 판단했을때 송신을 완료한 측이 연결 끊기 단계로 들어갑니다.
    - 웹의 경우 클라이언트 → 서버(리퀘스트), 서버 → 클라이언트(리스폰스)가 이루어져야 데이터 전달이 완료됩니다. 따라서 서버측이 연결끊기 단계에 들어갑니다.(`HTTP/1.0의 경우`)
    - 다른 애플리케이션을 사용하면 클라이언트 측이 먼저 끊을 수도 있음
    - 프로토콜 스택은 어느 쪽이던 먼저 연결 끊기 단계에 들어가도 좋게 만들어져 있습니다.

- **서버 측에서 연결 끊기 단계가 들어갔을때 동작**
    
    ![image](https://github.com/young0264/network_study/assets/66772624/e12d44fb-6e58-4499-82c4-7955c0d88606)

    
    **서버 측**
    
    - 서버측의 애플리케이션이 먼저 Socket 라이브러리의 close를 호출함
    - 서버측 프로토콜 스택은 TCP 헤더를 만들고, 연결 끊기를 나타내는 정보를 설정하고 IP 담당 부분에 의뢰해 클라이언트로 송신 요청을 보냄
    (`컨트롤 비트 FIN을 set함`)
    - 동시에 서버측의 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록함
    
    **클라이언트 측**
    
    - 서버 측 정보 수신
        - 서버에서 FIN에 1을 설정한 TCP헤더를 받으면 클라이언트 측 프로토콜 스택은 자신의 소켓에 서버측이 연결 끊기 동작에 들어감을 기록함
        - FIN을 1로 설정한 패킷을 받았음을 알리기 위해 ACK번호를 서버측에 반송함
        (이후 애플리케이션이 데이터를 가져올때까지 기다림)
    - 서버측으로 정보 송신
        - 애플리케이션(ex: 브라우저)이 read를 호출해 데이터를 가지러 오면 데이터를 전부 수신 완료했다는 사실을 애플리케이션에 알림
            - 수신 버퍼에 데이터가 남아있다면 해당 데이터를 건내줌
        - HTTP/1.0의 웹의 겨우 서버가 응답을 반송하면 끝나도록 규칙이 정해져 있음, 따라서 서버에서 보낸 데이터를 전부 수신 완료하면 클라이언트도 종료합니다.
        - 클라이언트 측 애플리케이션도 close를 호출하여 데이터 송수신 동작을 끝냄
        - 클라이언트 측 프로토콜 스택은 TCP 헤더를 만들고 FIN을 set해 IP 담당 부분에 의뢰해 서버로 송신함
    
    **서버 측**
    
    - 서버는 클라이언트의 FIN 번호를 확인하고 확인했다는 ACK 번호를 클라이언트로 보냅니다.
    
    **클라이언트 측**
    
    - 클라이언트는 서버측이 넘겨준 ACK 번호를 확인하고 서버와의 대화가 끝나게 됩니다.

> HTTP/1.0에서 웹 통신은 반드시 서버 측에서 연결 끊기 단계에 돌입합니다.
HTTP/1.1부터는 서버가 응답 메시지를 반송 한 후 클라이언트가 다음 리퀘스트 메시지를 보내도 좋게 되어있습니다. 이 경우 계속 리퀘스트 메시지가 없다면 클라이언트 측에서 먼저 연결 끊기 단계에 들어갈 수 있습니다.


<br>

### 2. 소켓을 말소한다.

서버와의 대화가 끝나면 소켓을 사용해 서버와 대화할 수 없게 됨, 하지만 바로 소켓을 말소하지 않고 잠시 기다린후 소켓을 말소합니다.

**소켓을 바로 말소하지 않는 이유(오동작 발생 위험)**

소켓을 바로 말소시켰을때 발생하는 문제를 통해 바로 말소하지 않는 이유를 알아볼 수 있습니다.

**오동작 예시**

클라이언트에서 먼저 열결 끊기 동작이 시작됐을때 다음과 같은 동작을 기대함

1. 클라이언트가 FIN 송신
2. 서버가 ACK 번호 송신
3. 서버가 FIN 송신
4. 클라이언트가 ACK 번호 송신

**오동작 설명**

- 하지만 2번 상황에서 ACK 송신을 확인한 클라이언트 측은 바로 소켓을 말소시킴
- 3번 송신을 클라이언트는 받을 수 없는 상황이 됨 (이때 서버는 FIN을 또 보낼수도 있음)
- 만약 새로운 소켓이 생성됐는데 이전 클라이언트 소켓과 동일한 포트를 사용한다면 서버가 보낸 FIN은 이전 소켓에 보낸 명령이지만 새로운 소켓에게 전달됨
- **새로운 소켓은 생성되지마자 바로 연결 끊기 동작에 들어가 버림 → 오동작**

**따라서 소켓을 즉시 말소하지 않고 잠시 기다립니다.**

- 기다리는 시간은 패킷을 다시 보내는 동작과 관계가 있음
- 패킷이 없어졌을때 몇분정도는 계속 다시 보내는 동작을 함 → 몇분이 지나면 회복 전망이 없는 것으로 판단해 다시보내기 멈춤
- 따라서 몇 분정도 기다리고 나서 소켓을 말소함

<br>

### 3. 데이터 송수신 동작 정리

![image](https://github.com/young0264/network_study/assets/66772624/d2a0fbc0-5e06-4d70-8a97-689ea87390a3)


출처: https://www.crocus.co.kr/1362

- 소켓 작성 단계
    - 패킷이 흐르지 않음

- 접속 동작
    1. **클라이언트 → 서버**: 
        - `SYN(1)`
        - `클라이언트 측 시퀀스 번호`
        - `서버가 클라이언트로 데이터를 보낼때 사용되는 윈도우 전달`
    2. **서버 → 클라이언트**
        - `ACK(클라이언트 측 시퀀스 번호 + 1), SYN(1)`
            - ACK 1을 더하는 이유: 클라이언트 측 시퀀스 번호까지는 데이터를 잘 받았고, 다음 번호(+1한 번호)부터의 데이터를 기다린다는 의미
        - `서버 측 시퀀스 번호`
        - `클라이언트가 서버로 데이터를 보낼때 사용되는 윈도우 전달`
    3. 클라이언트 → 서버
        - `ACK(서버 측 시퀀스 번호 + 1)`
    
- 데이터 송수신 동작(클라이언트 → 서버로 데이터 전달된다면)
    - 클라이언트 → 서버
        - Request Message 전달(데이터 시작 위치 표기한 시퀀스 번호 + 데이터)
        (TCP는 적당한 크기 조각으로 분할 및 TCP헤더를 맨 앞에 부가해 서버로 전달)
    - 서버 → 클라이언트
        - 서버는 시퀀스 번호부터 시작하여 데이터를 잘 받았다면 잘 받았고 다음 받을 위치를 기다린다는 ACK 번호 반송
    
    만약 서버가 클라이언트로 데이터를 전달하고, 클라이언트가 애플리케이션에 데이터를 건내주어 수신 버퍼에 빈 영역이 생기면 윈도우의 값도 기록하여 클라이언트에 통지함
    

- 연결 끊기 단계(서버측에서 먼저 끊는 경우)
    - 서버 → 클라이언트
        - FIN을 1로 set하여 전달
    - 클라이언트 → 서버
        - FIN확인 결과인 ACK set해 전달
    - 클라이언트 → 서버 (브라우저가 read했을때 데이터 전달 완료를 알린 후)
        - FIN을 1로 set하여 전달
    - 서버 → 클라이언트
        - FIN 확인 결과인 ACK set해 전달

<br><br>

## ✅ IP와 이더넷의 패킷 송수신 동작

### (들어가기 전 개념) 라우터와 허브

- `허브`
    - 컴퓨터와 컴퓨터 사이를 이어준다, 네트워크에 존재하는 컴퓨터(혹은 네트워크 기기) 중심에 위치하는 장비 (`스위칭 허브`, 리피터 허브)
        
        ![image](https://github.com/young0264/network_study/assets/66772624/e5195d13-29b6-4039-99ae-e72318968445)

        
- `라우터`
    - 자신의 네트워크가 흔히 인터넷이라고 말하는 다른 네트워크들의 집합체에 연결을 가능하게 해주는 장치이며 그 경로를 설정합니다. `작은 네트워크 덩어리들의 대표 대가리 느낌`
        
        ![image](https://github.com/young0264/network_study/assets/66772624/d79911b6-fe8c-4320-98b7-5b87e27f0ff3)

        
    
<br>

### 1. 패킷의 기본

- TCP 담당 부분은 접속, 송수신, 연결끊기의 각 단계에서 통신 상대와 대화할때 IP 담당 부분에 의뢰합니다.
- IP 담당 부분은 대화하는 데이터를 패킷의 모습으로 만들어 상대에게 도착하도록 합니다.

**패킷의 구성**

![image](https://github.com/young0264/network_study/assets/66772624/0eb83320-c3a6-4be7-a058-c7dfaab9e925)


- 패킷은 `헤더`, `데이터` 두 부분으로 구성됩니다.
    - 헤더: 수신처를 나타내는 주소 등의 제어 정보(ex: 택배 전표)
    - 데이터: 의뢰처에서 의뢰한 데이터(ex: 택배의 내용물)
- `IP 패킷`: MAC 헤더 제외
- `이더넷 패킷`: 위의 모든 구성은 이더넷 패킷에 속함

**패킷 통신 기본 구조**

1. 패킷의 송신처 기기가 패킷을 생성함(헤더에는 제어 정보, 데이터 부분에는 필요한 데이터들)
2. 가장 가까운 중계 장치에 패킷 송신
3. 중계 장치에선 도착한 패킷의 헤더를 조사해 패킷의 목적지를 판단함
    - 내부적으로 수신처의 방향을 기록해놓은 표와 같은 것을 사용함
    - 패킷의 헤더에 기록되어 있는 수신처와 표에 등록된 내용을 결합해 패킷의 수신처가 표의 어느 부분에 있는지 찾아냄
    - 등록된 내용을 통해 패킷의 목적지를 판단
4. 목적지를 향해 패킷을 송신하면 패킷은 다음 중계 장치에 도착함

> 위와 같은 방식으로 차례로 패킷을 송신하면 최종적으로 수신처의 기기에 패킷이 도착하게 됨
수신처와 송신처의 관계는 얼마든지 뒤바뀔 수 있음 → 송신처, 수신처를 묶어서 `엔드노드`라고 부른다.

반면에 중계 장치는 `중계 노드`(`중간 노드`)라고 부름

TCP/IP는 위와 같은 기본 패킷 통신 방식에서 좀 더 발전한 것입니다.
> 

**서브넷은 라우터와 허브라는 두 종류의 패킷 중계 장치를 이용해 패킷을 운반합니다.**

- 라우터: 라우터는 목적지를 확인하여 다음으로 가야 할 라우터를 찾아서 기록합니다. 
(IP의 규칙에 따라 패킷을 운반)
- 허브: 허브가 서브넷 안에서 기기간 패킷을 운반하여 다음 목적지 라우터에 도착하도록 합니다. 
(이더넷의 규칙에 따라 패킷을 운반)

**라우터와 허브의 패킷 운반**

- 송신처에서 패킷의 목적지가 되는 액세스 대상 서버의 IP 주소를 IP 헤더의 수신처에 기록함
- IP는 수신처의 방향을 조사하고 해당 방향의 다음 라우터를 조사
- MAC 헤더에 다음 라우터의 주소를 조사하여 기록하고 이더넷에게 어떤 라우터에 패킷을 도착해야 할지 전달
- 패킷을 송신하면 허브에 도착
    - 패킷의 목적지를 판단하기 위한 이더넷 용 표를 이용해 패킷의 목적지를 판단하여 다음 라우터로 중계함
- 라우터의 IP용 표를 이용해 다음 중계 라우터를 결정 및 다음 라우터에 패킷 송신
    - 초기 수신했을때의 MAC헤더는 버리고 송신할 때 새로운 MAC 헤더(다음 중계 라우터의)를 만들고 새 주소를 기록함
- 위와 같은 과정을 반복하여 패킷을 목적지에 도착하도록 함

**패킷을 목적지까지 전달할때 IP와 이더넷의 역할을 분담하는 이유 → 유연성**

- 이더넷 부분은 언제나 다른것으로 대체될 수 있음: 무선 LAN, ADSL, FTTH등
    - IP의 의뢰를 받아 패킷을 운반할 수 있는 것이라면 무엇이든지 이더넷 대신 사용 가능

<br>

### 2. 패킷 송수신 동작의 개요

**IP 담당 부분의 패킷 송신 동작**

- 실질적인 패킷을 운반하는 역할은 허브, 라우터와 같은 네트워크 기기의 역할이 됩니다.
- 하지만 실질적인 운반 이전에 몇가지 해야 할 일이 존재합니다.

**TCP 담당 부분은 IP 담당 부분에 패킷 송신을 외뢰함**

- 이때 TCP 담당 부분이 넘겨준 내용물은 IP 담당 부분에게는 그저 한덩이의 디지털 데이터로 간주합니다.
- 그 앞에 제어 정보를 기록한 헤더를 부가함
    - `IP 헤더`: IP 프로토콜 규칙에 따라 IP주소로 표시된 목적지까지 패킷을 전달할 때 사용하는 제어 정보
    (이더넷용 헤더)
    - `MAC 헤더`: 이더넷 등의 LAN을 사용하여 가장 가까운 라우터까지 패킷을 운반할 때 사용하는 제어 정보
    (IP용 헤더)
    

**만든 패킷을 네트워크용 하드웨어에 건내줌**

- 하드웨어는 무선 LAN, 이더넷 등을 말하지만 `LAN 어댑터`라고 통일하여 부릅니다.(책에선)
- 0, 1로 이루어진 디지털 데이터를 LAN 어댑터에게 건내주면 전기, 빛 신호로 바뀌어 케이블로 송출됨
- 해당 신호는 허브나 라우터 등의 중계 장치에 도착하고, 해당 중계 장치들은 다시 상대가 있는 곳 까지 패킷을 전달함

**상대에게 패킷이 도착하면 회답이 돌아옴**

- 단순히 송신 동작의 반대로 생각하면 됨

**IP 담당 부분은 TCP 담당부분의 결과를 신경쓰지 않음**

- `IP 패킷 송수신 동작은 패킷의 역할에 관계없이 동일`
- IP 담당 부분은 TCP 헤더 및 데이터 조각을 하나의 바이너리 데이터로 간주
- 내용을 보지 않으므로 TCP의 동작단계도 신경쓰지 않음
- 패킷의 순번이 바뀌든 아니든 신경쓰지 않음
- 어쨋든 의뢰받은 내용을 패킷의 모습으로 상대에게 송신, 혹은 수신하는 역할을 합니다.

<br>

### 3. 수신처 IP 주소를 기록한 IP 헤더를 만든다. - 부제: IP 담당 부분이 하는 자세한 일 (1)

![image](https://github.com/young0264/network_study/assets/66772624/3705c541-fd37-475b-9c39-443453cad0a8)


- 가장 중요한 것은 패킷을 어디로 전달해야 하는지를 나타내는 `수신처 IP 주소(Destination IP Address)` 입니다.
    - 수신처 IP 주소는 TCP 접속 동작시 애플리케이션에서 통지된 정보이며, TCP → IP 담당 부분으로 통지됩니다.
    - 결국 애플리케이션이 지정한 상대의 IP에 패킷을 그대로 송신합니다. (잘못된 IP여도 그냥 송신함)
- `송신처 IP 주소(Source IP Address)`도 설정합니다.
    - 하나의 LAN 어댑터에 IP 주소 하나가 할당되는데 여러개의 LAN 어댑터가 장착되어 있는 경우도 있습니다.
    - 이럴때 어떤 LAN 어댑터를 사용해야 하냐는 다음과 같이 결정할 수 있습니다.
        - 전송할 상대 라우터 결정 → 어떤 LAN 어댑터에서 패킷을 송신해야 하는지 결정됨 → IP주소가 결정됨
    - 송신처 IP 주소는 송신처가 되는 LAN 어댑터를 판단하여 주소를 설정함
    - 패킷을 건네줄 상대를 판단하는 방법은 라우터가 IP용 표(경로표 혹은 라우팅 테이블)를 사용하여 다음 라우터를 결정하는 동작과 같음
- `프로토콜 번호 필드`
    - 패킷에 들어간 내용물이 어디에서 의뢰를 받은것인지 나타냄
    - `TCP: 06`(16진수)
    - `UDP: 17`

<br>

### 4. 이더넷용 MAC 헤더를 만든다.

- IP 헤더를 만들었다면 IP 담당 부분의 앞에 `MAC 헤더`를 붙입니다.
- IP 헤더의 수신처 IP 주소에 패킷을 전달하는 목적지가 쓰여있지만, 이더넷에서는 TCP/IP 개념이 통용되지 않음
- **이더넷의 수신처 판단 구조로 사용되는 것은 MAC 헤더 입니다.**
- MAC 주소에서는 48bit를 전부 하나의 값으로 생각합니다.(고유명사)

![image](https://github.com/young0264/network_study/assets/66772624/95ef2fba-e873-47ac-a2bf-3319f7c5169b)


- 수신처 MAC 주소(48bit): 패킷을 전달해야 하는 상대의 MAC 주소
- 송신처 MAC 주소(48bit): 패킷을 송신한 송신처의 MAC 주소
- 이더 타입(16bit): IP 헤더의 프로토콜 번호와 비슷함, 사용하는 프로토콜의 종류를 나타냅니다.
    - 이더넷의 내용물은 IP나 ARP라는 프로토콜의 소켓이며, 각 대응하는 값이 규칙이 정해져있으므로 여기에 값을 기록
    - 0800: IP 프로토콜
    - 0806: ARP 프로토콜

이더 타입 및 송신처 MAC 주소(자체 LAN 어댑터)는 쉽게 기록할 수 있지만, 수신처 MAC 주소는 다소 복잡합니다.

<br>

### 5. ARP로 수신처 라우터의 MAC 주소를 조사한다

- **ARP의 원리 (Address Resolution Protocol)**
    - 이더넷에 연결되어 있는 모든 기기에 패킷을 전달하는 브로드캐스트를 이용해 수신처 IP 주소를 가지고 있는 모든 기기에 해당 IP를 가지고 있는지 묻습니다. (`브로드캐스트 주소는 네트워크의 맨 마지막 주소`)
    - 일치하는 기기는 자신의 MAC 주소를 응답으로 보냅니다.
    - 다만 패킷을 보낼때마다 위의 동작을 하면 ARP의 패킷이 계속 불어나기 때문에 한 번 조사한 결과는 `ARP 캐시`라는 메모리 영역에 보존합니다.
        - IP 주소가 변경된 경우, ARP 캐시의 내용과 실제 IP 주소가 다를 수 있으므로 ARP 캐시의 TTL은 최대 몇 분 정도입니다.

수신처 라우터의 MAC 주소를 찾았다면 IP 담당 부분은 모두 조합해 MAC 헤더를 IP 헤더의 앞에 붙여 패킷을 완성합니다.

**MAC 헤더는 이더넷에서 사용하기에 IP 담당 범위 밖이라고 생각될 수 있지만, 현실적으로 MAC 헤더를 붙여 패킷을 완성하기까지 IP에서 담당하는 것이 더 좋은 방법입니다.**

- LAN 어댑터에 건네주기 전에 IP 담당 부분에서 패킷을 완성하면 LAN 어댑터는 완성된 패킷만 송신합니다.
- IP 이외의 패킷인 경우도 LAN 어댑터에 건내주기 전에 패킷을 완성하면 됩니다.
- 따라서 IP 이외의 특수한 패킷에도 쉽게 대응할 수 있고, 여러가지 패킷에 대응할 수 있는 LAN 어댑터를 만드는 것이 좋습니다.

<br>

### 6. 이더넷의 기본

LAN 어댑터를 살펴보기 전에 이더넷에 대해서 설명합니다.

- 이더넷은 다수의 컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술
- 네트워크의 원리는 다음과 같습니다.
    - 한 대의 기기가 신호를 보내면 다른 기기 모두에게 신호가 도착함
    - 누구에게 보내는 신호인지 파악하기 위해 신호의 맨 앞부분에 수신처에 대한 정보를 작성(MAC 헤더)
    - 해당하는 기기는 패킷을 수신, 나머지는 폐기
- 위에서 설명한 네트워크의 원리를 구현한것이 `리피터 허브`이고, 좀 더 발전한 형태가 `스위칭 허브` 입니다.
    - 스위칭 허브는 수신처 MAC 주소로 나타내는 원하는 기기가 존재하는 부분에만 신호가 흐름, 다른 곳은 신호 흐르지 않음
- 이더넷은 3가지 성질로 위의 동작을 하기 위한 정보를 파악합니다.
    - `수신처 MAC 주소`: 패킷이 누구에게 갈 것인지 앎
    - `송신처 MAC 주소`: 누가 송신한것인지 앎
    - `이더 타입`: 패킷의 내용물이 무엇인지 앎
- 이더넷 접속 기기는 이더넷이라는 하나의 사양에만 기초하여 동작하므로 클라이언트 PC뿐만 아니라 서버나 라우터를 포함한 모든 기기에 공통적으로 적용됨
- IP와 마찬가지로 패킷의 내용은 보지 않음 → TCP 동작 단계에 상관 없이 모든 것에 공통(애플리케이션의 종류에도 영향 없음)

### 7. IP 패킷을 전기나 빛의 신호로 변환하여 송신한다

이더넷 패킷이 실제 케이블에 송출하기 위해서 디지널 데이터를 전기 혹은 빛의 신호로 변환합니다.
이 동작은 LAN 어댑터가 실행합니다. (정확히는 LAN 드라이버 소프트웨어가 LAN 어댑터를 제어함)

![image](https://github.com/young0264/network_study/assets/66772624/531c46f4-f406-4a40-96f2-3fe649172219)


LAN 어댑터의 구조는 위와 같습니다.

- LAN 어댑터 초기화 동작
    - LAN 어댑터는 전원을 공급하면 즉시 사용하는것이 아니라 초기화 작업이 필요함
    - LAN 어댑터의 ROM에는 전 세계에서 중복되지 않도록 일원화되어 관리되는 MAC 주소가 제조할 때 기록되어 있습니다.
    - LAN 어댑터의 ROM에 기록된 MAC 주소는 OS가 시동될때 LAN 드라이버가 MAC 회로에 설정합니다.

<br>

### 8. 패킷에 3개의 제어용 데이터를 추가한다

LAN 드라이버는 IP 담당 부분에게 패킷을 받으면 패킷을 LAN 어댑터의 버퍼 메모리에 복사합니다.
복사를 마친 후 패킷을 송신하도록 MAC 회로에 명령을 보내면 MAC 회로의 작업을 시작합니다.

![image](https://github.com/young0264/network_study/assets/66772624/5141d0e1-3896-4a71-94f6-37b6d8020ef1)


- `프리앰블`
    - 송신하는 패킷을 읽을 때의 타이밍을 잡기 위한 것으로 ‘10101010’과 같이 1과 0이 번갈아 나타나는 비트열입니다.
    - 수신측에서 신호를 수신할때 프리앰블 파형에서 타이밍을 판단합니다.
    - 디지털 데이터 → 전기 신호 변환
        - 0, 1을 전압이나 전류값에 대응해 구형파를 만듦
        - 데이터 신호가 1 혹은 0이 연속적으로 있다면 어디까지가 1 비트인지 구분하기 어려움
        - 이를 판단하기 위해 클록이라는 신호를 보냅니다.
        - 클록 신호가 상향 엣지(아래에서 위로 변화할때) 혹은 하향 엣지 일때 데이터 신호와 XOR 연산을 하여 합성하여 한 개의 신호를 만듭니다.
        - 합성 신호를 송신측에서 수신측으로 보냅니다.
        - **이런 클록 신호의 타이밍을 판단하기 위해 프리앰블이 사용됩니다.**
- `스타트 프레임 딜리미터`
    - 프리앰블 이후 이어지는데 프리앰블과 비트 패턴이 조금 다릅니다.
    - 수신측은 스타트 프레임 딜리미터를 이용해 패킷의 시작지점을 파악합니다.
- `FCS`
    - 32 비트의 비트열로 FCS를 이용해 패킷이 손상되어 있는지 오류를 검출할 수 있습니다.
    - 계산 바탕이 된 데이터 값이 1 비트라도 변화하면  FCS와 계산한 결과가 달라지므로 불일치를 통해 오류를 검출합니다.

<br>

### 9. 허브를 향해 패킷을 송신한다

![image](https://github.com/young0264/network_study/assets/66772624/bb103c4a-81c5-4971-aadd-54d4810fd9dd)


프리앰블, 스타트 프레임 딜리미터, FCS를 모두 부여하면 케이블에 송출하는 패킷이 완성됩니다.

신호를 송신할때는 두 종류가 존재합니다.

1. `리피터 허브 이용한 반이중 모드`
2. `스위칭 허브 이용한 전이중 모드`(3장에서 설명)

**반이중 모드 - 정상 흐름**

- 케이블에 다른 기기가 송신한 신호가 흐르고 있는지 조사 (있다면 끝날때까지 대기)
- 신호가 정지했거나, 흐르지 않고 있다면 송신 동작을 시작
- MAC 회로가 프리앰블의 맨 앞부터 1비트씩 디지털 데이터 → 전기 신호로 변환
- PHY(MAU) 회로가 신호를 케이블에 송출하는 형식으로 변환하여 송신함
    - 수신도 같이 맡아서 함
    - PHY(MAU) 회로는 MAC 회로가 송신한 신호의 형식을 변환하기 위한 변환 회로
- 이더넷은 수신자에게 송신 신호가 제대로 도착했는지 확인하지 않음
    - 케이블 길이가 짧아서 오류가 날 확률이 적음, 오류가 난다 하더라도 TCP가 검출하므로 굳이 확인할 필요가 없음

**반이중 모드 - 신호 송신할때 다른 곳에서 송신한 수신 신호가 잡힌다면? (신호의 충돌)**

- 동시에 복수의 기기가 송신 동작에 들어간다면 신호의 충돌이 발생함
- 송신 동작 중지 및 충돌이 일어난 사실을 다른 기기에 알리기 위한 `재밍 신호`를 흘림
- 송신 동작을 잠시 멈추고 다시 한 번 송신 동작을 시도하는데, 충돌난 기기의 재 충돌 방지를 위해 MAC 주소를 바탕으로 난수를 생성하여 대기시간을 계산함
- 아예 다른 기기와 또 충돌이 발생하면 대기 시간을 2배 늘려서 다시 보냄
    - 2배씩 최대 10번정도 반복
    - 해결되지 않으면 오류로 판단

<br>

### 10. 돌아온 패킷을 받는다

![image](https://github.com/young0264/network_study/assets/66772624/001df5d5-9d3a-4f6d-834a-0834873418cb)


패킷 수신시 동작 (수신 신호선에서 신호를 받는것으로부터 시작됨)

- 신호 맨 앞의 프리앰블을 이용해 파형에서 타이밍을 계산함
- 스타트 프레임 딜리미터를 만나면, 다음 비트부터 디지털 데이터로 변환하는 동작을 개시
- `PHY(MAU) 회로`에서 신호를 공통 형식으로 변환하여 `MAC 회로`로 보냄
- `MAC 회로`에서 신호를 맨 앞부터 디지털 데이터로 변환하여 `버퍼 메모리`에 저장
- 패킷의 맨 앞부터 계산식에 적용해 FCS의 값을 계산하고, 실제 패킷 끝의 FCS 값과 비교
    - 다른값이라면 오류 패킷으로 간주해 폐기함
- MAC 헤더의 수신처 MAC 주소를 조사 - LAN 어댑터 초기화할때 설정한 MAC 주소와 비교후 다르다면 폐기
- MAC 주소가 일치하면 버퍼 메모리에 저장
- MAC 회로의 역할이 끝나면 패킷 수신 사실을 컴퓨터 본체에 통지함
    - 인터럽트 구조 사용
    - 컴퓨터 본체가 실행하고 있는 작업에 끼어들어 LAN 어댑터쪽에 주의를 기울이게 함
- LAN 드라이버는 LAN 어댑터의 버퍼 메모리의 패킷을 추출
    - MAC 헤더의 타입 필드 값으로부터 프로토콜을 판별함
- 프로토콜에 맞는 프로토콜 스택에게 패킷을 건네줌

<br>

### 11. 서버의 응답 패킷을 IP에서 TCP로 넘긴다

웹 서버에서 패킷이 돌아온 것으로 간주하고, 다음 프로토콜 스택의 동작을 추적합니다.
(패킷의 타입은 TCP/IP인 0800)

- LAN 드라이버는 TCP/IP의 프로토콜 스택에 패킷을 건넴
- IP 담당 부분은 IP 헤더 부분부터 조사해 포맷의 문제여부를 확인 및 IP 주소를 조사합니다.
- 서버 응답 패킷을 수신한 것이 클라이언트 PC라면 수신처 IP 주소는 수신한 LAN 어댑터에 주소와 일치할 것입니다.
    - 만약 주소가 다르다면 오류가 있으므로 IP 담당 부분이 ICMP라는 메시지를 사용해 통신 상대에게 오류를 통지합니다. (아래와 같은 대표적인 오류 메시지 존재)
        
        ![image](https://github.com/young0264/network_study/assets/66772624/38f7db77-9ad9-43ef-ab1b-29294fb6096e)

        
- 주소가 올바르면 IP 헤더의 플래그를 통해 수신 패킷이 분할된 것인지 확인합니다. 
(IP 프로토콜의 fragmentation, IP 헤더의 플래그를 통해 판단함)
    - 분할된 수신 패킷이라면 IP 담당 부분 내부의 메모리에 일시적으로 보관합니다.
    - IP 헤더에 있는 ID 정보에 같은 값을 가진 패킷이 도착하기를 기다립니다.
    (분할된 패킷은 Identification이 동일함)
    - fragment offset은 패킷이 원래 어느 위치에 있었는지를 나타냅니다.
    - 이러한 정보들을 바탕으로 패킷이 모두 도착하면 원래의 모습으로 돌리는 리어셈블링 동작을 합니다.
- 완성된 패킷이라면 TCP 담당 부분에 건네줍니다.
- TCP 담당부분은 네 가지 항목을 조사하여 해당하는 소켓을 찾습니다.
    1. 수신처 IP 주소
    2. 송신처 IP 주소
    3. TCP 헤더에 기록된 수신처 포트 번호
    4. 송신처 포트 번호
- 소켓을 찾았다면 상황에 따라 적절한 동작을 실행합니다.

> **TCP 담당 부분과 IP 담당 부분을 명확히 분리하지 않는 이유

담당 범위를 여유 있게 해석하여 TCP 담당 부분과 IP 담당 부분을 나누지 않고 하나의 프로그램으로 묶어 융통성이 있는 형태로 만드는 쪽이 좀 더 이해하기 편하고 실용적입니다.

추가로 네 가지 항목을 조사하는 이유는 6장에서 더 자세히 설명합니다.**
> 

<br>

### (실습) Wireshark에서 실제 IP fragments

- **공유기를 사용한다면 기본 게이트웨이 주소를 찾아야 함**
    - `netstat -rn | grep "default" | awk '{print $2}’`
        - default netstat을 잡아서 두번째 항목을 출력 → 기본 게이트웨이 주소

- **ping(ICMP) 명령을 이용해 이더넷 MTU(1500 byte)를 초과한 패킷을 보내어 fragments flag가 set되게 하기**
    - `ping -s 2000 기본게이트웨이주소`
    (2000바이트 짜리 패킷을 기본게이트웨이 주소에 보내겠다)
    - Ping은 ICMP 프로토콜을 사용하지만 IP 프로토콜을 사용하는건 동일하기에 테스트할 수 있음

- **결과**
    
    ![image](https://github.com/young0264/network_study/assets/66772624/e0b01a5a-1bf9-4c20-9ec7-3d47096f1a71)

    
    ICMP echo request를 받은 호스트가 동작중이므로 ICMP echo reply가 돌아옴
    
    이때 데이터는 2000바이트를 전송했으므로 2개의 fragments로 나뉨
    
    ![image](https://github.com/young0264/network_study/assets/66772624/766dd49e-0b74-4869-a95c-a9f41b6cf127)

    
    ![image](https://github.com/young0264/network_study/assets/66772624/e824216e-d074-472b-ae94-dcb6600f8214)

    
    **첫번째 패킷에서 More fragments가 set 됨을 확인할 수 있습니다.**
    
- 참고
    
    [wireshark IP fragments 패킷 필터링](https://fliedcat.tistory.com/54)
    
    [Network - ping 설명 ICMP Internet Control Message Protocol 설명 여러가지](http://webs.co.kr/index.php?document_srl=20506&mid=network)
    
    [맥/윈도우 PING 테스트하는 방법 - Mac In June](https://macinjune.com/all-posts/mac/tip/맥-윈도우-ping-테스트하는-방법/)
    

<br><br>

## ✅ UDP 프로토콜을 이용한 송수신 동작

![image](https://github.com/young0264/network_study/assets/66772624/30d79456-f0f7-4421-b3ae-3f18a97eba70)


![image](https://github.com/young0264/network_study/assets/66772624/0daab2ae-87d4-4b4b-af2e-c52e43bc860b)


출처: https://velog.io/@hidaehyunlee/TCP-%EC%99%80-UDP-%EC%9D%98-%EC%B0%A8%EC%9D%B4

<br>

### 1. 수정 송신이 필요없는 데이터의 송신은 UDP가 효율적이다

- TCP가 복잡한 이유
    - 데이터를 확실하고 효율적으로 전달하기 위해
    - 도착한 패킷은 다시 보내지 않고, 도착못한 패킷은 다시 보내는 구조가 필요함
    - 위와 같은 세밀한 동작을 제어하기 위해 복잡함

하지만, 한 개의 패킷만 필요한 경우 TCP 처럼 굳이 복잡한 구조가 필요하진 않습니다.

<br>

### 2. 제어용 짧은 데이터는 UDP

![image](https://github.com/young0264/network_study/assets/66772624/577395a6-250c-4b01-a8cf-7f970140cd20)


- DNS 서버에 대한 조회 등 제어용으로 실행하는 정보 교환은 한 개의 패킷으로 끝나는 경우가 많습니다. 따라서 TCP가 아닌 UDP를 사용합니다.
- UDP는 수신 확인, 윈도우와 같은 부분이 없으므로 데이터 송수신 전에 데이터를 주고받거나, 접속, 연결 끊기 단계 같은 것들이 존재하지 않습니다.

- 송신
    - 애플리케이션에서 송신 데이터를 받으면 UDP 헤더를 부가하고 IP에 의뢰해 송신하기만 함
- 수신
    - IP헤더의 수신처 IP, 송신처 IP, UDP 헤더의 수신처 및 송신처 포트와 소켓에 기록된 정보를 결합함
    - 이후 대상 애플리케이션을 파악하고 데이터를 건내줌 → 패킷이 유실되어도 책임지지 않음
    - 오류가 발생한다면 회답이 돌아오지 않으므로 애플리케이션은 데이터를 다시 보내면 된다.

### 3. 음성 및 동영상 데이터

- 음성이나 영상 데이터는 결정된 시간 안에 데이터를 건네주어야 함
- TCP의 경우 수신 확인 응답이 존재하므로 시간이 더 소요됨
- 음성이나 영상 데이터는 데이터가 다소 없어도 큰 문제가 되지 않음 (끊기거나, 잡음)
- **따라서 다시 보낼 필요가 없고, 다시 보내도 쓸모가 없는 상태가 되므로 UDP가 적합**

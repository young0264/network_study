1장은 4개의 단계로 이루어짐

1. HTTP Request 메시지를 작성한다.
2. 웹 서버의 IP 주소를 DNS 서버에 조회한다.
3. 전 세계의 DNS 서버가 연대한다.
4. 프로토콜 스택에 메시지 송신을 의뢰한다.

<br><br>

## ✅ HTTP 리퀘스트 메시지를 작성한다.

### 1. 탐험 여행은 URL 입력부터 시작한다

**URL (Uniform Resource Locator)**

![image](https://github.com/young0264/network_study/assets/66772624/fcb99e93-3b6d-40e5-b3d8-0f7731c0cff5)


- `Scheme(protocol)`: 브라우저가 리소스를 요청하는데 사용할 프로토콜을 나타냄
- `Domain Name + Port(권한)`: 권한에는 도메인과 포트가 모두 포함됩니다.
    - 도메인은 주로 도메인 이름(en-US)으로 구성되지만 IP주소도 사용할 수 있습니다.
    - 포트는 IP내에서 애플리케이션을 상호 구분하기 위해 사용되는 번호입니다. (HTTP(80), HTTPS(443) → 생략 가능, 그 외에는 필수)
- `Path to the resource`: 웹 서버에 있는 리소스의 경로, 실제 파일의 위치를 나타내기도 하지만, 요즘은 물리적 실체가 없고 웹 서버가 추상적으로 처리하도록 합니다.
- `Parameters`: 웹 서버에 제공할 매개변수들입니다.
- `Anchor`: 리소스 자체의 특정 부분에 대한 앵커입니다. (책갈피) 응답으로 받은 컨텐츠에서 앵커(책갈피) 지점의 콘텐츠를 표시하도록 지시합니다.
    - 프래그먼트 식별자 라고도함 → # 뒤의 부분은 Http Request와 함께 서버로 전송되지 않음
    

http:, ftp:, mailto:와 같은 여러 기능들을 브라우저가 제공합니다. **브라우저는 몇 개의 클라이언트 기능을 겸비한 복합적인 소프트웨어 입니다’**

<br>

### 2. 브라우저는 먼저 URL을 해독한다.

브라우저는 우선 웹 서버에 보내는 `Request Message`를 작성하기 위해 URL을 해독해야 합니다.

![image](https://github.com/young0264/network_study/assets/66772624/90dad1c0-0bed-4827-84bd-e388ba9c47d1)


위 그림을 통해 URL의 각 부분을 나누고 해독합니다.

위의 경우에는 `/path/to/my/myfile.html`이라는 파일을 접근하기 위한 요청으로 해독됩니다.

- 파일명은 생략이 가능하다. (아래 방식 모두 가능)
    - `http://www.example.com/`
    - `http://www.example.com`
- 물리적 실체가 아닌 리소스를 요청
    - `http://www.example.com/users`
        
        웹 서버는 추상적인 요청을 해석하고, 맞는 작업을 수행하고 알맞은 응답을 클라이언트에게 내림(사용자의 목록을 요청하는것으로 이해할 수 있음) 
        
<br>

### 3.  HTTP 프로토콜의 기본 개념 (Request)

HTTP 프로토콜은 다음과 같이 동작합니다.

1. 클라이언트가 Request Message를 작성 및 요청을 보냄
    - Request Message는 `무엇을?` `어떻게 하겠다.` 가 있습니다.
    - 여기서 무엇을은 `URI`, 어떻게 하겠다는 `HTTP Method`가 됩니다.
2. 웹 서버는 요청을 처리하고 Response Message를 작성 및 응답을 함
    - 무엇을 어떻게 하는지 파악하고 요구에 맞게 동작합니다. 이후 응답 메시지를 작성하여 반환합니다.
    - 응답의 핵심은 `Status Line (Http Version + Status Code + Response Message)`
    - Response Header를 제외하고 Response Body에 요청한 데이터가 같이 오게 됩니다. 웹 브라우저는 메시지 안의 데이터를 추출하여 화면에 표시하면서 HTTP의 동작이 종료도미

- `URI(Uniform Resource Identifier)`: 하나의 리소스를 가리키는 문자열로, URL도 URI에 포함됩니다.
URL은 웹 상에서 위치를 통해 리소스를 식별합니다.
- `HTTP Method`: 주어진 리소스에 대해 수행해야 할 작업을 나타내는 일련의 요청들을 메서드로 정의합니다.
    - GET: 지정된 리소스의 표현을 요청, GET은 데이터를 요청할 때만 사용해야 합니다만, URL에 쿼리 파라미터를 붙여서 간단한 파라미터 데이터를 전달할 수 있습니다.
        
        ![image](https://github.com/young0264/network_study/assets/66772624/1cf15236-0ffa-4ba5-b51f-363770d843e6)

        
    - POST: 데이터를 서버로 전송함, 요청 본문의 유형은 Content-Type 헤더로 표시되며 전송되는 형식은 Request Body에 쿼리 스트링 타입으로 전송됩니다.
        
        ![image](https://github.com/young0264/network_study/assets/66772624/4ae55ef0-7b81-4844-acad-798e844331ae)

        
    - GET, POST의 차이: [https://hiiwee.tistory.com/23#📌 HTTP 메소드 GET과 POST의 차이-1](https://hiiwee.tistory.com/23#%F0%9F%93%8C%20HTTP%20%EB%A9%94%EC%86%8C%EB%93%9C%20GET%EA%B3%BC%20POST%EC%9D%98%20%EC%B0%A8%EC%9D%B4-1)
- `Status Code`: 요청에 대한 실행 결과가 정상 종료인지 혹은 이상이 있는지를 알려줍니다.

<br>

### 4. HTTP Request Message를 만든다.

```swift
// Request Message 예시
GET /index.php?name=hoseok HTTP/1.1 // Request Line
Host: uu.ac.kr // Request Message Header
Accept: text/html

// Message Body 영역, GET이라 Body가 비어있음
```

<br>

### 5. Http Response Message

```swift
HTTP/1.1 200 OK // Status Line
Content-Type: text/html
Content-Length: 1000

<html>
<body>
<img src="image.png">
</body>
</html>
```

요청 메시지와 첫 라인을 제외하고 형식은 동일합니다.
첫 줄에선 요청의 실행 결과를 간단하게 알 수 있는 Status Code, Response Message를 확인할 수 있습니다.

일반적으로 하나의 HTTP Request에는 하나의 HTTP Response가 발생됩니다.

따라서 응답받은 HTML 파일에 정적인 리소스들이 포함되어 있다면 별도의 HTTP Request를 생성하여 받아와야 합니다.

<br><br>

## ✅ 웹 서버의 IP 주소를 DNS 서버에 조회한다.

<br>

### 1. IP 주소의 기본

- HTTP Message를 만들면 OS에 의뢰하여 액세스 대상의 웹 서버에 송신함
- OS에 송신하기 위해서는 IP 주소로 메시지를 받을 상대를 지정해야 함

**IP 주소의 구성**

- 인터넷, 사내 LAN은 TCP/IP의 개념에 기초하여 만들어짐
- 이때 서브넷을 각 라우터에 접속시키면서 전체 네트워크가 구성 됩니다.
    
    ![image](https://github.com/young0264/network_study/assets/66772624/8fe4a8d6-1e71-41c9-8e3a-82e7133b8997)

    
- 위와 같이 구성된 네트워크에서 00동 00번지라는 형태로 네트워크의 주소를 할당하는데 이것이 IP
- 동에 해당되는 번호는 `네트워크 번호`, 번지에 해당하는 번호는 `호스트 번호`

**TCP/IP의 기본적인 원리**

- 패킷 통신 규약중 하나 입니다.
- 송신측이 보낸 메시지는 서브넷 안에 있는 허브가 운반하고, 송신측에서 가장 가까운 라우터까지 도착합니다. 이후 반복적인 작업을 통해 최종 목적지 라우터까지 메시지를 보냅니다.

**IP 주소 구조**

- IP 주소는 32비트의 디지털 데이터, 이를 1바이트씩 점으로 구분하여 10진수로 표기함
- IP 주소의 네트워크 번호와 호스트 번호의 구분은 `네트워크 마스크` 혹은 `서브넷 마스크`를 통해 구분할 수 있습니다.
- `10.11.12.13/24` → 상위 24비트는 네트워크 마스크, 하위 8비트는 호스트 번호
- 상위 24비트를 전부 1로 변경하고, 하위 8비트는 0으로 변경하면 네트워크 마스크 혹은 서브넷 마스크가 됩니다.
    - `10.11.12.13/24`의 넷마스크 → `255.255.255.0`
- 호스트 번호 부분 비트가 모두 1이라면 서브넷에 있는 기기 전체에 패킷을 보내는 브로드캐스트를 나타냅니다.
    - `10.11.12.255/24` (브로드캐스트)

**IP 주소 연산**

- 특정 네트워크 혹은 서브넷 블록의 주소의 개수 구하기
    
    `N = NOT (net mask) + 1 = 0.0.0.255 + 1 = 256`개의 주소를 가짐
    
- 첫번째 주소
    
    `First Address = (address) AND (net mask) = 10.11.12.0/24`
    
- 마지막 주소
    
    `Lasd Address = (address) OR ((NOT) net mask) = 10.11.12.255/24`

<br>

### 2. 도메인 명과 IP 주소를 구분하여 사용하는 이유

- 실제 서버명 대신 IP 주소를 써도 올바르게 작동 합니다.
- IP 주소는 외우기 어려우므로 URL에선 도메인 이름을 사용하는것이 적절합니다.
- IP 주소는 최대 32비트이고, 도메인명은 최대 255바이트까지 가능합니다.
- 라우터에서 마저 도메인 명을 사용하면 데이터 운반에 많은 시간이 소요되며 네트워크 지연이 발생합니다.
- **따라서 라우터는 IP 주소를 사용합니다.**
- 도메인 이름 ↔ IP간 변환을 해주는 역할을 `DNS`가 해줍니다.

<br>

### 3. Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다.

- IP 주소를 얻기 위해 DNS 서버(네임서버)에 조회 메시지를 보내면 응답을 통해 조회할 수 있습니다.
- `DNS 클라이언트 ↔ DNS 서범(네임서버)` 처럼 이를 바라볼 수 있습니다.
- DNS 클라이언트 요청을 `리졸버`가 처리해줍니다., 리졸버가 IP 주소를 조사하는 과정은 name resolution이라 합니다.
- Socket 라이브러리는 여러 프로그램들의 부품이 모여 있으며 리졸버는 그 속에 들어있는 부품 중 하나입니다.
- Socket 라이브러리는 OS에 포함되어 있는 네트워크의 기능을 애플리케이션 레벨에서 호출하기 위한 부품들로 구성되어 있습니다.

자세한 DNS 설명

[https://hanamon.kr/dns란-도메인-네임-시스템-개념부터-작동-방식까지/](https://hanamon.kr/dns%EB%9E%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%84%A4%EC%9E%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D%EA%B9%8C%EC%A7%80/)

### 4. 리졸버를 이용하여 DNS 서버를 조회함

- 브라우저 등의 애플리케이션 프로그램을 만들 때 리졸버를 호출하면 리졸버가 DNS 서버에 질의합니다.
- DNS 서버의 응답으로 브라우저에서 지정한 메모리에 IP를 저장합니다.
- 브라우저가 웹 서버에 메시지를 보낼때는 메모리에서 IP 주소를 추출해 HTTP Request Message와 함께 OS에 건내주며 송신을 의뢰합니다.

<br>

### 5. 리졸버 내부의 작동

- 리졸버를 호출하면 프로그램의 제어가 리졸버로 넘어갑니다.
- 리졸버에선 DNS 서버에 문의하기 위한 메시지를 만듭니다.
- 메시지를 DNS 서버에 요청합니다. 이때 직접 메시지 송신을 하지 않고 OS 내부에 포함된 `프로토콜 스택`을 호출하여 실행을 의뢰 합니다.(결국 OS를 거쳐야함 → 네크워크 관련 처리를 도맡아 하므로)
- 프로토콜 스택을 호출하면 LAN 어댑터를 통해 메시지가 DNS 서버를 향해 송신됩니다.
- IP를 찾으면 다시 프로토콜 스택 → 리졸버로 전달되고 리졸버에서 내용을 해독 및 추출합니다.
- 애플리케이션이 호출시에 지정했던 메모리에 IP 주소를 저장합니다.

→ 특정 계층에서 일을 처리하지 않고 계속 하위 계층에게 일을 처리하도록 요청함
→ DNS 서버에 메시지를 송신할떄도 DNS 서버의 IP 주소 필요 → 컴퓨터에 설정되어 있음

<br><br>

## ✅ 전 세계의 DNS 서버가 연대한다

<br>

### 1. DNS 서버의 기본 동작

- 클라이언트에서 조회 메시지를 받고, 해당 내용에 응답하는 형태로 동작
- 조회 메시지에는 3가지 정보가 포함됨
    - `이름`: 서버나 메일 배송 목적지와 같은 이름(도메인 이름)
    - `클래스`: 인터넷 이외의 네트워크들의 클래스(현재는 인터넷만 사용 `IN`)
    - `타입`: 조회 메시지 이름의 어떤 타입의 정보가 지원되는지 나타냄 (A: 이름에 IP가능, MX: 이름에 메일 배송 목적지 지원)

**전송과정**

- 위의 조회 정보를 포함한 조회 메시지를 DNS 서버에 전송
- DNS 서버는 등록된 정보를 찾아서 이름, 클래스, 타입 3가지가 일치하는 것을 찾습니다.
- MX 타입으로 조회시 우선순위, 메일 서버의 이름이 조회되는데 이름 뿐만 아니라 메일 서버 자체의 IP 주소
함께 회답합니다.
    - 우선순위: 복수의 메일 서버가 등록되어 있을때 어느 메일 서버를 우선 선택해야 하는지를 구분하기 위한 값

그 밖에서 PTR(IP주소에서 이름), CNAME(alias(닉네임)을 붙임), NS(새로운 IP 주소 등록), SOA(도메인 자체의 속성 정보 등록) 타입 등 여러 타입이 존재합니다.

<br>

### 2. 도메인의 계층

DNS 서버는 분산 계층을 통해 각 도메인들을 등록합니다.

![image](https://github.com/young0264/network_study/assets/66772624/f8aa3483-cc5a-4c14-b807-992315450183)


- 각 DNS 서버는 연대하여 어디에 정보가 등록되어 있는지를 찾아냅니다.
- 실제 도메인 이름들의 .을 통해 구분할때 뒤로 갈수록 상위 계층에 해당됩니다.
    - 도메인 이름 자체가 계층적 구조를 가짐

- 이렇게 나눠진 도메인의 정보는 일괄적으로 DNS 서버에 등록합니다.
    - 단, 하나의 도메인을 분할하여 복수의 DNS 서버에 등록하는것은 안됩니다.
- DNS 서버에는 여러개의 도메인을 등록할 수 있습니다.

<br>

### 3. 담당 DNS 서버를 찾아 IP 주소를 가져온다.

- DNS 서버는 역트리(Inverted tree*)* 구조로, 최상위 도메인은 항상 루트 도메인부터 시작됩니다.
    - 루트 도메인에 등록된 IP 주소는 더 많지만, 사용되는 IP 주소는 13개입니다.
    - 루트 도메인은 모든 DNS 서버에서 접근할 수 있습니다.
- 상위 도메인은 항상 다음 하위 도메인에 접근할 수 있습니다.
- 따라서 클라이언트에서 특정 DNS에 접근하면 루트 도메인을 경유하여 상위 → 하위 도메인으로 탐색해가며 최종 DNS 서버에 도착하게 됩니다.

실제 동작과정의 예시는 다음과 같습니다.

![image](https://github.com/young0264/network_study/assets/66772624/40065436-5477-45b2-962e-f50ac9070a61)


- 번호 순서대로 따라가다 보면 여러 DNS 서버(네임 서버)를 Local DNS Server가 다른 DNS 서버에 질의 하는 모습은 재귀적인 특성을 보입니다.
- 따라서 Local DNS Server의 질의를 `Recursive Query`라고 부릅니다.
- 또한 Local DNS Server가 다른 DNS 서버에 반복적으로 질의 하는 작업을 `Iterative Query`라고 합니다.

<br>

### 4. DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다.

- DNS 서버는 한 번 조사한 이름을 캐시에 기록할 수 있습니다. 조회한 이름에 해당하는 정보가 캐시에 있다면 즉시 그 정보를 회답할 수 있기에 빠른 응답을 할 수 있습니다.
- 이름이 존재하지 않는다는 회답 또한 캐싱될 수 있습니다. 따라서, 존재하지 않는 이름에 대해 조회가 들어오면 빠르게 응답합니다.

<br><br>

## ✅ 프로토콜 스택에 메시지 송신을 의뢰한다

### 1. 데이터 송•수신 동작의 개요

- IP 주소를 조사하고, 웹 서버에 메시지를 보내기 위해 OS 내부의 프로토콜 스택에 의뢰합니다.
(네트워크를 이용하는 애플리케이션 전체에서 공통적인 작업)
- Socket 라이브러리에 들어있는 부품을 이용하는데, 여러 부품들의 조합으로 이루어집니다.
    - 데이터를 송수신할 클라이언트와 서버측간 소켓을 생성하고 write & read 하는 작업들의 부품 조합

**소켓의 동작**

1. 소켓을 생성함(소켓 작성)
2. 서버측의 소켓에 파이프를 연결(접속 단계)
3. 데이터를 송•수신함(송수신 단계)
4. 파이프를 분리하고 소켓을 제거함(연결 끊기 단계)

위 4가지 동작을 실행하는 것은 OS 내부의 프로토콜 스택이고, Socket 라이브러리는 단순히 프로토콜 스택에게 파이프 연결 및 데이터 송수신을 의뢰하지, 실질적인 작업을 하는 주체는 아닙니다.

<br>

### 2. 소켓의 작성 단계

```c
<메모리 영역> = gethostbyname("www.lab.cyber.co.kr");

<디스크립터> = socket(<IPv4>, <스트림형>, ....); // 1. 준비

connect(<디스크립터>, <송신데이터>, <송신데이터길이>); // 2. 접속

<수신 데이터 길이> = read(<디스크립터>, <수신 버퍼>, ...); // 3. 수신

close(<디스크립터>); // 4. 연결 끊기
```

1. **준비**
    - socket을 호출하면 소켓 내부로 제어가 넘어가 소켓을 만드는 동작을 실행합니다.
    이후 디스크립터를 반환받게 됩니다.
        - `디스크립터`: 컴퓨터 내부에서 복수의 데이터 송수신 동작이 동시에 진행될때 각 소켓을 식별하기 위한 식별자
2. **파이프를 연결하는 접속 단계**
    - connect를 호출할때 디스크립터, IP주소, 포트 번호 3가지를 넘겨주며 프로토콜 스택에 소켓에 접속하도록 의뢰합니다.
    - 프로토콜 스택은 해당 디스크립터를 보고 어느 소켓을 서버측의 소켓에 접속할지 판단하여 접속 동작을 실행합니다.
    - `IP 주소 + 포트 번호`를 통해 어느 컴퓨터의 어느 소켓과 접속할지 지정할 수 있습니다.
        - 서버측 디스크립터를 클라이언트가 알 수 없음 → IP주소 + PORT 번호를 통해 서버측의 컴퓨터와 연결할 소켓을 식별합니다.
            - HTTP 통신이라면 80번 포트를 HTTPS 라면 443 포트를 서버측에서 사용합니다.
            - 클라이언트의 포트는 프로토콜 스택이 적당한 값을 골라서 할당합니다. 이후 프로토콜 스택이 서버측에 해당 포트번호를 통지합니다

<br>

### 3. 메시지를 주고받는 송•수신 단계

- 소켓에 데이터를 부으면, 반대쪽 소켓에 데이터가 도착합니다.
- 애플리케이션은 소켓을 직접 다룰 수 있기에 Socket 라이브러리를 통해 프로토콜 스택에 일을 의뢰 합니다.(`write`)
    - HTTP Request Message가 송신할 데이터입니다.
    - 데이터는 네트워크를 통해 그대로 서버측에 도착합니다.
- 서버측에서의 응답도 소켓을 통해 클라이언트로 전달됩니다.
    - 애플리케이션 프로그램에 마련된 메모리 영역인 수신 버퍼에 응답 메시지를 저장해둡니다.

<br>

### 4. 연결 끊기 단계에서 송•수신이 종료된다.

- 소켓 라이브러리의 close를 호춣하면 연결 끊기 단계에 들어가도록 프로토콜 스택에 의뢰합니다.
    - HTTP 프로토콜에서는 응답 메시지의 송신이 완료됐다면, 웹 서버측에서 연결 끊기 동작을 실행합니다.
    - 클라이언트는 이를 확인하고 연결 끊기 단계에 돌입합니다.
    - 브라우저가 read로 수신 동작을 의뢰했을때 수신 데이터가 아닌 연결이 끊겼다는 사실을 통지하여 브라우저 또한 연결 끊기 단계에 들어갑니다.
- HTTP는 1개의 데이터를 읽을때마다 위의 4가지 단계를 거치게 됩니다.
(1.1버전에서는 연결 끊김 없이 복수의 요청과 응답을 주고받을 수 있는 방법을 제공합니다.)

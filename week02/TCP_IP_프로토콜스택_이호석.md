# 📌 2장: TCP/IP의 데이터를 전기 신호로 만들어 보낸다.(1~3절)

- `프로토콜`: 컴퓨터, 원거리 통신 장비에서 메시지를 주고 받는 양식과 규칙의 체계 (통신 규약 및 약속)

> 프로토콜 스택은 운영 체제(OS) 내부에 구현되는 네트워크 통신을 관리하기 위한 소프트웨어 계층입니다. 프로토콜 스택은 OSI 7계층 모델 또는 TCP/IP 4계층 모델과 같은 네트워크 계층 모델을 기반으로 작동하며, 네트워크 인터페이스와 통신하고 데이터의 전송을 관리합니다.
`TCP/IP 프로토콜 스택의 애플리케이션 계층은 실제 응용 프로그램과 사용자와 상호 작용하는 부분을 나타냅니다.` 예를 들어, 웹 브라우저, 이메일 클라이언트, 파일 전송 프로그램 등이 여기에 해당합니다. 이 계층에서는 HTTP, FTP, SMTP, DNS 등과 같은 프로토콜을 사용하여 데이터의 종단 간 통신을 제공합니다. 애플리케이션 계층은 운영 체제 외부에서 작동하며, 네트워크 통신을 위한 인터페이스를 제공합니다.
`반면에 다른 계층들, 즉 전송 계층, 인터넷 계층 및 네트워크 인터페이스 계층은 주로 운영 체제 내부에서 작동합니다.` 전송 계층은 데이터의 신뢰성과 흐름 제어를 담당하고, 인터넷 계층은 데이터 패킷의 라우팅과 전송을 관리합니다. 네트워크 인터페이스 계층은 실제 네트워크 하드웨어와 상호 작용하여 데이터의 물리적 전송을 처리합니다.
따라서, 정확한 설명은 프로토콜 스택이 주로 운영 체제 내부에 구현되어 네트워크 통신을 관리하며, 애플리케이션 계층은 운영 체제 외부에서 응용 프로그램과 사용자와의 상호 작용을 관리한다는 것입니다.

→ 위와 같이 프로토콜들이 스택 처럼 쌓여있음으로 프로토콜 스택이라 부름(거기에 OSI 7계층, TCP/IP 4계층(혹은 5계층)들이 대표적은 프로토콜 스택의 예시가 됩니다.)

<br><br>

## ✅ 소켓을 작성한다.

### 용어 정리

- `ICMP`
    - (Internet Control Message Protocol) 패킷을 운반할때 발생하는 오류를 통지하거나 제어용 메시지를 통지할때 사용되는 프로토콜
- `ARP`
    - (Address Resolution Protocol) IP주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용되는 프로토콜
    - `MAC 주소`: (Media Access Control Address) 데이터 링크 계층에서 통신을 위한 네트워크 인터페이스에 할당된 고유 식별자
        - MAC 주소는 간단히 말해 인터넷을 할 수 있는 이더넷 기반 기기에는 모두 다 하나씩 할당되어 있는 고유한 ID라고 할 수 있습니다.
- `LAN`
    
    ![image](https://github.com/young0264/network_study/assets/66772624/f26fbff7-7594-480e-9f46-287419fc0c48)

    
    - (Local Area Network) 근거리 통신망으로 반경 약 1km의 영역에 한정된 컴퓨터 및 주변장치 그룹으로 구성됩니다.
    - 라우터, 스위치, 액세스 포인트, 케이블은 모두 LAN에 속하며 이더넷, Wi-Fi 기술을 통해 작은 집이나 사무실부터 대형 빌딩에 이르기까지 변화하는 영역 내에서 장치를 인터넷 서버 및 웹 서버에 연결할 수 있습니다.
        - `Ethernet`: 이더넷은 CSMA/CD(Carrier Sense Multiple Access/Collision Detection) 프로토콜을 사용한 통신을 말합니다
            
            유선 랜을 사용한 통신을 보통 이더넷이라 함
            
            이더넷 ≠ 인터넷이며 이더넷은 단순히 랜선에 연결된 목적지로 통신을 하기 위한 기술이라고 생각할 수 있습니다. (인트라넷의 경우 이더넷을 사용하지만, 인터넷에 연결되어 있지 않음)
            
        - `Wi-Fi`: 이더넷은 유선입니다. 케이블 없이 간편하게 네트워크를 만들기 위한 무선 LAN기술 중 하나입니다. 무선 LAN의 규격은 IEEE802.11로, 제조사가 다른 무선 LAN 기기끼리도 원할하게 통신하기 위해 Wi-Fi Alliance라는 업계 단체가 상호 접속성을 인증한 브랜드를 Wi-Fi라고 부르는데, 현재는 무선 LAN 자체를 가리켜 Wi-Fi라고 표현하게 됐습니다.
        - `라우터`: 이더넷과 무선 LAN은 같은 네트워크 안에서 데이터를 전송할 수 있습니다. 다른 네트워크에 데이터를 전송하려면 서로 다른 네트워크의 연결이 필요한데 이때 사용하는 네트워크 기기가 라우터입니다.
            
            (`라우팅`이란 라우터가 데이터의 목적지가 어느 네트워크에 접속해 있는지 판단해 연결된 네트워크의 라우터로 전송하는 것을 말합니다.)
            
    
<br>

### 1. 프로토콜 스택의 내부 구성

![image](https://github.com/young0264/network_study/assets/66772624/e6c4ee48-be01-4d7c-a9c1-c1d16fd9a2a4)


- 상 → 하로 다음 작업을 의뢰 합니다. (아래로 갈수록 좀 더 저수준에 가까워짐)
    - 각 스택간의 상하 관계는 때에 따라 역전될 수 있음

**OS 내부에서의 프로토콜 스택 동작**

- `TCP and UDP`
    - 브라우저나 메일 등의 일반적인 애플리케이션은 TCP를 사용하여 데이터를 송수신합니다.
    - DNS 서버에 대한 조회 등에서 짧은 제어용 데이터를 송수신 하는 경우에는 UDP를 사용합니다.
- `패킷(packet)`
    - 인터넷에서 데이터를 주고받을때 네트워크를 통해서 전송되는 데이터 조각
    (우체국에서 화물을 적당한 덩어리로 나눠 행선지로 전송하는 느낌)
- `IP`
    - 패킷을 통신 상대까지 운반하는 것이 IP의 주 역할임
    - 내부에서 ICMP와 ARP 프로토콜을 다루는 부분이 포함되어 있습니다.
        - 패킷 전달시 오류, 제어용 메시지를 통지하거나, MAC주소를 조회할때 사용됨
- `LAN 드라이버`
    - LAN 어댑터의 하드웨어를 제어하는데 LAN 어댑터는 실제 송수신 동작(케이블에 대해 신호를 송수신하는 동작)을 실행합니다.

<br>

### 2. 소켓의 실체는 통신 제어용 제어 정보

통신이 정상적으로 이뤄지기 위해서는 내부에서 사용되는 제어정보들을 메모리 영역에 기록해야 합니다.

- `제어 정보`: 통신 상대 `IP addr`, `PORT`, `통신 동작의 진행 상태`, `송신 동작 후 경과 시간` 등
    
    이러한 **메모리 영역은 사실 소켓이며 프로토콜 스택은 소켓에 기록된 제어 정보를 참조하면서 동작함**
    
- `클라이언트 측 소켓 예시`
    
    ![image](https://github.com/young0264/network_study/assets/66772624/9678631d-5fa2-4a3a-97be-f92fb8264bbf)

    
    위와 같이 서버측의 ip주소와 포트 번호를 넘겨주고, 실제 접속을 합니다. 이러한 ip주소 및 포트 번호는 소켓에 기록됩니다.
    
<br>

### 3. Socket을 호출했을 때의 동작

![image](https://github.com/young0264/network_study/assets/66772624/4fede3c9-f5e1-40a4-9df3-677983d0b237)


1. **프로토콜 스택에 소켓 생성을 의뢰 및 디스크립터 반환 받음**
    - 소켓 측 메모리 영역을 확보 == 제어 정보를 담을 그릇 준비
    - 생성 직후라 초기 상태 데이터만 존재
- 2, 3, 3`, 4동작은 다음 절에서 설명

**프로토콜은 결국 디스크립터를 통해 정보를 얻는다.**

- 디스크립터가 생성된 이후, connect, read, write, close에서 모두 디스크립터가 사용됩니다.
- 디스크립터는 누구와 누가 통신하는지, 어떤 상태인지 등의 정보가 전부 기록되어 있으므로 프로토콜 스택쪽에서 필요한 정보가 있을때 쉽게 이용할 수 있습니다.

<br><br>

## ✅ 서버에 접속한다 (2번 동작)

![image](https://github.com/young0264/network_study/assets/66772624/89b97aec-affa-4ab8-ad08-e1a27ab031f0)


<br>

### 1. 접속의 의미

- 소켓을 만들면 애플리케이션은 connect를 호출합니다.
- 프로토콜 스택은 자기쪽의 소켓을 서버측 소켓에 접속합니다.

**프로토콜 스택이 수행하는 접속의 의미**

- 소켓 생성 직후에는 아무 것도 기록되어 있지 않습니다. → 통신 상대도 모름
- 이때 접속을 위해 connect를 호출하는데 다음과 같은 역할을 수행합니다.
    - 통신 상대와의 사이에 제어 정보를 주고 받아 소켓에 필요한 정보를 기록하고 데이터 송수신 가능 상태로 만들어야 합니다.
        - `제어 정보`: IP 주소, 포트 번호 등
    - 데이터 송수신 동작시 사용되는 메모리 영역을 버퍼 메모리라고 부릅니다. (접속 동작시 버퍼 메모리 확보)

<br>

### 2. 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다

제어 정보는 2가지 종류가 존재합니다.

1. **TCP 헤더, 이더넷 헤더, IP 헤더**와 같은 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 제어 정보
2. 소켓에 기록하여 프로토콜 스택의 동작을 제어하기 위한 정보
(애플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보 등이 **수시로 기록됩니다.)**

**제어 정보 (1) 헤더**

![image](https://github.com/young0264/network_study/assets/66772624/3cc471bf-3eee-4833-84f8-e94381502b78)


- 통신 동작에서 필요한 정보는 위와 같이 TCP의 사양으로 규정됩니다.
- 위 헤더는 고정항목이므로 접속, 송수신, 연결 끊기와 같은 단계에서 클라이언트 - 서버간 통신이 있을때마다 위 제어정보가 필요합니다.
- 클라이언트, 서버 사이에 주고받는 패킷 맨 앞부분에 추가됨
    
    ![image](https://github.com/young0264/network_study/assets/66772624/c326c217-edda-4d57-a713-b3ee244ac8fb)

    
- 접속 동작에서는 아직 데이터 송수신을 하지 않으므로 전달 데이터가 없고 패킷의 내용은 제어 정보만으로 이루어져 있습니다.
- 패킷 앞에 있기에 헤더라 불림 (TCP 헤더, 이더넷 헤더, IP 헤더 등)
- 클라이언트와 서버는 헤더에 필요한 정보를 기록하여 연락을 취하며 통신 동작을 진행합니다.
    
    ```java
    송신측: 데이터 송신 동작을 개시합니다.
    수신측: 예, 잘 알겠습니다.
    송신측: 00번째 데이터를 보냅니다.
    수신측: 00번째 데이터를 받았습니다.
    ```
    

**제어 정보(2) - 소켓 메모리 영역**

- 소켓에 기록하여 프로토콜 스택의 동작을 제어하기 위한 정보를 기록함
- 애플리케이션에서 받은 정보, 통신 상대로부터 받은 정보들이 **수시로 기록됨**
- 소켓의 제어 정보 == 프로토콜 스택의 프로그램
- 소켓에 기록한 제어 정보는 상대측에서 볼 수 없음
    - 결과만 동일하다면 만드는 과정은 달라도 됨 → OS마다 차이가 존재
    - 따라서 위와 같은 TCP 헤더가 존재하는 이유도 공통된 결과를 생성하기 위함 → 표준
- `netstat -ano`(윈도우), `netstat -anv`(맥)와 같이 터미널 환경에서 소켓 제어 정보중 중요한 일부를 볼 수 있는 기능도 있음
    
    
<br>

### 3. 접속 동작의 실제

접속 동작은 connect를 호출하는 곳부터 시작됩니다.

```java
connect(<디스크립터>, <서버측의 IP 주소와 포트 번호>, ...)
```

- 위의 명령을 통해 인자로 전달한 정보들이 프로토콜 스택의 TCP 담당 부분에 전달됨
- TCP 담당 부분은 IP 주소로 표시된 상대, 즉 서버의 TCP 담당 부분 사이에 제어 정보를 주고받음

대화는 다음과 같이 이루어짐 (3 way handshake)

- **클라이언트 → 서버**
    - 데이터 송수신 동작의 개시를 나타내는 제어 정보를 기록한 TCP 헤더를 만듦(송신처와 수신처의 포트번호가 중요함)
    - 송수신 포트 번호를 통해 클라이언트측 소켓, 서버측 소켓을 지정함
    - 접속 소켓을 확실히 했다면 컨트롤 비트인 `SYN`을 set 시킴(0 → 1)
    - TCP 헤더를 IP 담당 파트에 전달해 송신하도록 의뢰
- **서버 → 클라이언트**
    - 서버측은 받은 패킷을 서버측 IP 담당 파트 → TCP 담당 파트로 전달함 (역순)
    - 서버측 TCP 담당 파트는 수신처 포트 번호에 해당하는 소켓을 찾아냄
    (수신처 포트번호와 같은 포트 번호를 가진 소켓)
    - 찾은 소켓에 필요 정보를 기록함하고 접속 동작이 **진행중** 상태로 변경
    - TCP 담당 파트는 응답을 돌려보내는데 동일하게 TCP 헤더를 만들고 컨트롤 비트 `SYN`, `ACK`를 1로 set하여 반환합니다.
        - ACK를 1로 올리는 이유는 패킷 도착 확인을 하면서 동작을 진행할때 **확인 비트**로 사용됨
    - IP 담당 파트에게 다시 클라이언트에게 반송하도록 함
- **클라이언트 → 서버**
    - IP 담당 파트 → TCP 담당 파트가 받아서 서버측 접속 동작의 성공 여부를 판단함
    (SYN이 1인지)
    - 접속 성공이라면 소켓에 서버의 IP주소, 포트 번호 등과 함께 접속 완료를 나타내는 제어 정보를 기록함
    - 패킷이 정상적으로 도착함을 알리기 위해 다시 ACK를 1로 set해 서버로 전달합니다.

> 위 과정을 거치면 소켓은 데이터를 송수신할 수 있는 상태가 됩니다.
마치 파이프와 같은 것으로 연결된것 처럼 보이므로 이를 **커넥션**이라 부릅니다.
close를 호출하여 연결을 끊을 때 까지 계속 커넥션은 존재하며 connect가 끝났으므로 애플리케이션을 제어할 수 있게 됩니다.

<br>

### Wireshark에서 실제 Transmission Control Protocol의 모습

- **`TCP 제어정보`**
    
    ![image](https://github.com/young0264/network_study/assets/66772624/350579e6-33b7-4aec-bf91-248c77f955a6)

    
- **`실제 데이터 전송전에 송신 → 수신, 수신 → 송신 확인 절차`**
    
    ![image](https://github.com/young0264/network_study/assets/66772624/c5b19bdb-bb48-485c-b67a-9122463f7e93)

    
- **`실제 데이터 주고받음 Request(GET), Response(401)`**
    
    ![image](https://github.com/young0264/network_study/assets/66772624/24ec6516-93a7-4aa7-b6b4-9b5578cdaaf4)

<br><br>  

## ✅ 데이터를 송•수신 한다


### 1. 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다

- connect에서 애플리케이션에 제어가 되돌아오면 데이터 송수신 동작에 들어갑니다. (write, read)
- 프로토콜 스택은 데이터를 1바이트씩 읽기만 하고 내용은 알지 못합니다.
- 송신측 데이터를 한번에 전송할수도 있지만 그러지 않을 수도 있습니다.
- 받은 데이터를 얼만큼 송신측 버퍼 메모리에 저장할지는 OS마다 다르지만 몇가지 기준이 존재합니다.

**언제 데이터를 송신할지에 대한 판단**

1. `MTU라는 매개변수 활용 (Maximum Transmission Unit)`
(한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이, 이더넷은 보통 1500바이트)
    - 헤더 제외한 순수 데이터의 최대 길이는 MSS(Maximum Segment Size)
    - 따라서 MSS를 초과하거나 가깝게 차면 데이터를 저장하고 송신 동작을 함
    
    ![image](https://github.com/young0264/network_study/assets/66772624/a8e6d1fc-e9ff-4815-8874-685620b10a37)

    
2. `타이밍으로 판단`
    
    MSS에 가깝게 데이터를 저장하면 송신 동작이 지연됩니다. 따라서 프로토콜 스택 내부의 타이머를 이용해 일정 시간 이상 경과하면 패킷을 송신합니다.
    

위 두가지의 판단은 Trade-Off가 있으며 OS 종류, 버전에 따라 달라질 수 있습니다.
또한 버퍼에 머물지 않고 즉시 전송할 수 있는 옵션을 애플리케이션측에서 지정할 수 있습니다.

<br>

### 2. 데이터가 클 때는 분할하여 보낸다

![image](https://github.com/young0264/network_study/assets/66772624/c270a72b-203d-48f7-8d4f-cd2ca447fa9f)


- 송신 데이터가 MSS를 초과하면 송신, 버퍼에 들어있는 데이터를 맨 앞부터 차례로 MSS 크기에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 송신합니다.

<br>

### 3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다

- TCP에는 송신한 패킷이 상대에게 올바르게 도착했는지 확인하고, 도착하지 않았다면 다시 송신하는 기능이 있습니다. 이를 통해 송신 이후 확인 동작을 하게 됩니다.

![image](https://github.com/young0264/network_study/assets/66772624/92dfac52-b537-4c69-86fc-067d96f104d5)


- 데이터를 조각으로 분할할때 조각이 통신 개시부터 따져 몇번째 바이트에 해당되는지 세어둡니다. 이후 데이터의 조각을 송신할때 세어둔 값을 TCP 헤더의 `Sequence Number` 항목에 기록합니다.
    - 위의 방식을 통해 시퀀스 번호가 순차적으로 존재하지 않는다면 누락을 판단할 수 있습니다.
    - Sequence Number는 1부터 시작하지 않고 항상 난수를 바탕으로 산출한 초기값을 사용합니다.
    (수신측은 난수를 알 수 없으므로 이를 전달하는 과정도 필요합니다.)
        
        ![image](https://github.com/young0264/network_study/assets/66772624/5798e46a-38ef-4786-bf99-9da99e44ae5f)

        
- 수신측에서 정상적으로 데이터를 받았다면 몇번째 바이트까지 수신한 것인지를 계산하고 해당 값을 ACK number에 기록하여 송신측에 알려줍니다. (이때 ACK 컨트롤비트로 1로 set합니다.)
    - `클라이언트 → 서버 전송`
        
        ![image](https://github.com/young0264/network_study/assets/66772624/a90b873d-bb70-4015-b08d-dd2531f1bc93)

        
    - `서버 → 클라이언트 전송(PSH를 통해 버퍼 채우기 전에 즉시 전송함)`
        
        ![image](https://github.com/young0264/network_study/assets/66772624/70ac546a-e69d-4d88-a8a7-a3254683ae7a)

        
    - `위 동작을 수신 확인 응답이라고 함`
    

“**클라이언트 → 서버”로의 데이터 전달 과정**

- **접속 동작 (3 way handshake)**
    1. 클라이언트에서 서버로 보내는 데이터에 관한 시퀀스 번호의 초기값을 클라이언트에서 산출하고 서버에 통지함
    (SYN set - Synchronize의 약자로, 시퀀스 번호의 초기값을 통지하여 송신측과 수신측의 보조를 맞춰 데이터의 누락을 검출하는 상황을 정비한다는 의미)
        
        ![image](https://github.com/young0264/network_study/assets/66772624/d1cc5d96-3235-42c9-a2ee-e58a74f8e870)

        
        - 클라이언트(50423)측 시퀀스 번호 전달
        (클라이언트 → 서버 데이터 전달시 사용됨): `Sequence Number (raw): 2109166401`
    2. 서버에서 클라이언트 측 시퀀스의 초기값으로 부터 ACK번호를 산출하고 클라이언트에 반송해야 합니다.
        
        이때 서버에서 클라이언트로 데이터를 보내는 데이터에 관한 시퀀스 번호의 초기값을 서버에서 산출해 클라이언트에게 같이 통지합니다.(ACK, SYN set)
        
        ![image](https://github.com/young0264/network_study/assets/66772624/f94ccaa2-fec9-4a83-a246-b3ce76b02510)

        
        - 클라이언트 측 시퀀스 번호 확인
        `Acknowledgment number (raw): 2199166402`(이전 번호까지는 안전히 받았으니 다음 번호(1을 더한 번호)를 기다린다.
        - 서버측 시퀀스 번호를 클라이언트에게 전달
        (서버 → 클라이언트 데이터 전달시 사용됨): `Sequence Number (raw): 1068350647`
    3. 클라이언트는 서버가 그랬듯이 서버측 시퀀스 번호의 초기값에서 ACK 번호를 산출해 서버에 전달 합니다.(ACK set)
        
        ![image](https://github.com/young0264/network_study/assets/66772624/ad4a6163-9e71-4fbb-a0a8-255f616ad735)

        
        - 서버측 시퀀스 번호 확인
        `Acknowledgment number (raw): 1068350648`(1068350647까지는 잘 받았고 다음 번호(~8)을 기다린다.
- **송 수신 동작**
    1. 본격적인 데이터 송수신 동작을 진행함
        1. 클라이언트 → 서버 진행이라면 클라이언트는 시퀀스 번호 + 데이터를 서버측으로 넘겨주고 서버는 이를 계산한 ACK 번호를 응답합니다.
        2. 서버 → 클라이언트 진행이라면 서버측에서 시퀀스 번호 + 데이터를 클라이언트측으로 넘겨주고 클라이언트는 이를 계산한 ACK 번호를 응답합니다.

> 위 구조를 통해 네트워크 어디에서 오류가 발생하여 ACK 번호가 도착하지 않았을때 해당 패킷을 다시 보내어 오류를 검출하고 회복처리를 할 수 있습니다.
따라서 LAN 어댑터, 버퍼, 라우터 모두 회복 처리를 진행하지 않아도 됩니다.
서버가 다운됐다면 몇번 보내보고 종료합니다.

<br>

### 4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다

- ACK 번호가 돌아오길 기다리는 시간을 타임아웃 값이라 합니다.
- ACK 번호가 돌아오길 무한정 기다릴 수 없기에 일정 대기시간을 정해둬야 합니다.
- TCP는 대기 시간을 동적으로 변경하는 방법을 취합니다.
    - 데이터 송신 동작시에 ACK 번호가 돌아오는 시간을 계측하고, 그것에 맞게 대기 시간을 조절합니다.

<br>

### 5. 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다

![image](https://github.com/young0264/network_study/assets/66772624/915d787a-0d1f-4dce-918a-0c578f50b53b)

- ACK 번호가 돌아올때까지 기다리는 동안 데이터를 전송하는 측에서 아무것도 하지 않는다면 **시간낭비**
- 윈도우 제어는 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보냅니다. (시간낭비 최소화)
- 계속 패킷을 보내면 수신측 버퍼가 부족한 상황(수신측의 능력을 초과)이 있을 수 있습니다.
- 이를 해결하기 위해 수신 측은 송신측에 수신 가능한 데이터 양을 통지하고, 송신 측은 해당 크기를 초과하지 않도록 데이터를 송신합니다.
- 수신 처리가 끝나고 수신 버퍼에 빈 부분이 생기면 해당 분량만큼 수신할 수 있는 데이터 양을 늘리므로 TCP 헤더의 윈도우 필드에서 이것을 송신측에 알립니다.
- 그림과 달리 실제 동작은 시퀀스 번호 및 ACK 번호와 같이 양방향 대화가 이루어집니다.
- 수신 가능한 데이터 양의 최대값을 윈도우 사이즈라고 합니다. (TCP 정밀 조정하는 매개변수 중 하나)

<br>

### 6. ACK 번호와 윈도우를 합승한다

- 윈도우 통지 동작은 수신 버퍼의 빈 영역이 늘어났을때 송신측에 대해 발생함
    - 빈영역이 늘어났다 == 수신측이 수신 버퍼에서 데이터를 추출해 애플리케이션에 건내 주었다
- ACK 번호에 대한 번호는 수신측에서 데이터를 받았을 때 내용을 조사하여 정상 수신을 확인할 수 있는 경우에 송신측에 전송함

**위 두가지 영역은 비슷한 부분이 있습니다.**

- 송신측 데이터가 수신측에 도착하여 수신 동작이 정상이다 → ACK 번호 송신측에 통지
- 이후 데이터를 애플리케이션에 건내주었다 → 새로 업데이트된 윈도우를 송신측에 통지

**두 개의 패킷을 따로 전송하는 것은 효율성이 저하됩니다.(너무 많은 패킷)**

- 따라서 수신측은 ACK 번호나 윈도우를 통지할 때 바로 보내지 않고 잠시 기다립니다.
- 그리고 ACK 번호의 송신을 대조할때 윈도우 통지가 발생하면 두개를 하나의 패킷에 묶어서 통지합니다.

**연속된 ACK 번호 통지 혹은 윈도우 통지가 발생해도 하나로 묶습니다.**

- 연속하여 일어나면 제일 끝에 있는 ACK 번호 혹은 가장 마지막에 업데이트된 버퍼 영역을 계산하여 통지하면 됩니다.

하지만 실제 Wireshark를 통해 패킷을 보면 바로바로 윈도우 사이즈를 통지하는것을 볼 수 있다. 왜 그럴까? ㅠ

<br>

### 7. HTTP 응답 메시지를 수신한다

HTTP Request를 보내면 HTTP Response가 와야 합니다. (read 프로그램 호출)

read 프로그램을 호출하면 프로토콜 스택은 수신 버퍼에서 데이터를 추출하려 합니다.

프로토콜 스택이 데이터를 수신하는 동작은 다음과 같습니다.

- 수신한 데이터 조각 및 TCP 헤더의 내용을 조사해 누락 데이터를 확인하고, 문제가 없다면 ACK 번호를 반송
- 데이터 조각을 버퍼에 임시 보관
- 조각을 연결하여 데이터를 원래 모습으로 복원하고 애플리케이션에 건내줌
    - 구체적으로 수신 데이터를 애플리케이션이 지정한 메모리 영역에 옮겨 기록한 후 애플리케이션에 제어를 되돌려줌
    - 애플리케이션에 데이터를 건내주고 타이밍을 가늠해 윈도우를 송신측에 통지
